---
layout: post
title:  "Baby's first buffer overflow exploit"
date:   2015-07-21
---

The TV show [*Mr. Robot*](http://www.usanetwork.com/mrrobot) airing on the USA Network has been gaining a lot of popularity and I just so happend to start working through the [Embedded Security CTF](https://microcorruption.com/), so I thought I'd take this opportunity to give a quick write-up of how I solved one of the earlier levels and show you guys how a certain type of hack called a "stack buffer overflow attack" is done.  This is also known as "stack smashing."

<b>Warning: If you're working through the CTF yourself and haven't completed the *Cusco* puzzle yet, don't read on unless you want it spoiled!</b>

<b>Warning 2: I barely know what I'm talking about ever, but especially when it comes to "hacking."  Read at your own risk.</b>

If you haven't seen the show, you, the audience, are essentially the imaginary friend of the show's hacker vigilante protagonist Elliot Alderson, and to whom he shares his (often, morphine-addled) thoughts.  In the pilot episode, the bulk of Elliot's hacks comprise finding the passwords of his targets through a mix of social engineering and [dictionary attacks](https://en.wikipedia.org/wiki/Dictionary_attack).  The show is surprisingly enjoyable, and there don't seem to be (so far anyway) any glaring errors or misuse of concepts or terminology that would "ruin" the immersion for the more tech-savvy audience.  No [two agents, one keyboard action here](https://www.youtube.com/watch?v=u8qgehH3kEQ).

In the CTF, the goal is very similar: to gain entry into buildings around the world, each of which are guarded by an electronic lock called the LockIT Pro.  The only interaction the hacker has with the lock is through the password input. If we know the password then gaining entry is trivial, but we of course don't, so we have to be creative with what we enter as the "password".

The process of solving a level follows a general two-step process: work with a "debug" lock that is just like the real lock and figure out the right input that opens it, then use the input on the "real" lock.  As the name suggests, in the debug step you have a lock that is attached to a debugger, so you have access to pretty much everything going on in the lock, such as the state of the processor and memory.  You have access to a dump of the raw assembly running on the lock, so you know exactly what's going on.  The goal is to find a vulnerability in the code that will allow us to gain access without knowing the "real" password.

The first few levels are relatively simple because we can actually figure out the actual password that opens the lock because the code does a simple string compare.

For example, here's the `check_password` procedure in *Sydney* level of the game:

{% highlight asm %}
cmp #0x455d, 0x0(r15)
jnz $+0x1c
cmp #0x4d68, 0x2(r15)
jnz $+0x14
cmp #0x3a7d, 0x4(r15)
jne #0x44ac
mov #0x1, r14
cmp #0x5252, 0x6(r15)
jeq #0x44ae
clr r14
mov r14, r15
ret
{% endhighlight %}

For most anyone, me included, this might as well be giberrish but if we study it long enough, we will come to the conclusion that it's *roughly* equivalent to the following bit of C:

{% highlight c %}
int check_password(const char* password) {
  // "string compare" is true if they match, false otherwise
  if (strcmp("E]Mh:}RR", password)) {
    return 1;
  } else {
    return 0;
  }
}
{% endhighlight %}

and so we simply input the password it's looking for.  Easy 10 points.

###Cusco
The *Cusco* puzzle is where things change because the code tells us <b>nothing</b> about how the password looks, other than that it's between 8 and 16 characters long.  Obviously, brute forcing the password is out of the question, and not in the spirit of the game.  The process of verifying a password is also no longer done on the lock, but through something called a "Hardware Security Module" (HSM).  This thing is basically a device attached to the lock itself that contains the password, and the only thing the lock does is pass it a character string, and it in turn tells the lock if the password is correct or not.  We will need to rely on mistakes in the code to cause the lock to open, even if the HSM tells it the password is wrong.

Before we move on, we need to establish a few fundamental truths.  We will put all of these ideas together to exploit a single mistake in the code:

* The locks are powered by the Texas Instruments MSP 430 CPU.  The MSP 430 is a little-endian CPU, which means that in memory, the least significant byte of a value appears first.  For example, for the 16-bit vale `0xCAFE`, it would appear in memory as `0xFE 0xCA`.

* The MSP 430 is a 16-bit CPU, and in particular all addresses are 16-bit, or 2-byte values.

* All local variables are stored on a contiguous part of the memory called the <b>stack</b>.

	The stack can be thought of conceptually as a gun magazine: each byte of data is a bullet, and the first bullet that's pushed in is the last one that comes out.

  The CPU has a special register called `sp` that stands for "Stack Pointer."  It contains the address to the "top" of the stack.

  Places in memory that have address equal to or greater than the the value in `sp` are "on" the stack.

  The stack "grows" downward.  That is, the more data there is on the stack, the lower the value of `sp`.  Conversely, the less data there is on the stack, the higher the value of `sp`.

  If a procedure needs to make room on the stack for its variables, it does so by decreasing the value of `sp`.  For example, if we need 4 bytes of stack space, then we would do something like set `sp` to the current value in `sp` minus 4.

* The way to call a procedure in MSP 430 assembly is using the `call` instruction.  `call` takes an address, pushes the address of the instruction that comes after it onto the stack, *then* jumps to the supplied address.  The address that was pushed onto the stack is the *return address* of the procedure that was invoked.  In other words, that's where the CPU will go next after the invoked procedure is done.

* All procedures end with the `ret` instruction.  This causes the CPU to jump to the address stored at the top of the stack.  So if the 2-byte value stored at the top of the stack was `0x4400`, then the CPU would start executing the instructions at that address.

With these things in mind, here's a part of the code on the *Cusco* lock.  Everything we're interested in happens in the `login` function:

{% highlight asm %}
add	#0xfff0, sp
mov	#0x447c "Enter the password to continue.", r15
call	#0x45a6 <puts>
mov	#0x449c "Remember: passwords are between 8 and 16 characters.", r15
call	#0x45a6 <puts>
mov	#0x30, r14
mov	sp, r15
call	#0x4596 <getsn>
mov	sp, r15
call	#0x4452 <test_password_valid>
tst	r15
jz	#0x4532 <login+0x32>
call	#0x4446 <unlock_door>
mov	#0x44d1 "Access granted.", r15
jmp	#0x4536 <login+0x36>
mov	#0x44e1 "That password is not correct.", r15
call	#0x45a6 <puts>
add	#0x10, sp
ret
{% endhighlight %}

In C, it's equivalent to:

{% highlight c %}
void login() {
  // reserve some stack space to store the password the user types in.
  char pass_buff[16];

  // the puts function prints the string to the lock's screen
  puts("Enter the password to continue.");
  puts("Remember: passwords are between 8 and 16 characters.");

  // Get the password string from user input.  Tell it to get up to 0x30 bytes.
  getsn(pass_buff, 0x30);

  // Ask the HSM if the password is correct
  // returns 1 if valid, 0 otherwise.
  int password_valid = test_password_valid(pass_buff);

  if (password_valid) {
    // password is correct so unlock the door.
    unlock_door();
    puts("Access granted.");
  } else {
    puts("That password is not correct.");
  }

  return;
}
{% endhighlight %}

The entrypoint, `main`, just calls the `login` function:

{% highlight asm %}
call #0x4500 <login>
{% endhighlight %}

and in C:

{% highlight c %}
void main() {
  login();
}
{% endhighlight %}

Can you spot the bug?

The error is in the line `getsn(pass_buff, 0x30)`.  We ask the lock to get *up to* 0x30 bytes, which is 48 in base 10.  That's 3 times the maximum password length!  That on its own isn't a bad thing, but here we're telling `getsn` to store the data in the `pass_buff` buffer.  If we take a look again at when we declared `pass_buff`, it looks like this: `char pass_buff[16];`.  We only reserve enough room for 16 bytes, not 48.  It's also a variable local to `login` so that means it lives on the stack.  So what happens if we "accidentally" type in a password that's longer than 16 characters long?  Well in this case, `getsn` has no idea how big the `pass_buff` buffer actually is, so it will just be an obedient function and keep writing the entire password onto the stack.  Since we didn't reserve 48 bytes, what will happen is that values that were put on to the stack before we made room for `pass_buff` will be overwritten!

Let's take a look at `main`:  it uses the `call` instruction to invoke `login`.  Remember what this instruction does: it pushes the return address onto the stack before jumping to the address of `login`, and the first thing that `login` does is make room on the stack for `password`.  That means the return address, that is, the address that the CPU will jump to after `login` is done, is 16 bytes away from `pass_buff`!  So if we typed in *18* bytes, the first 16 would completely fill the `pass_buff` buffer, and the last two bytes would overwrite the return address that was put there by the `call` instruction.  The `ret` instruction at the end of `login` will cause the CPU to jump to this address.  We take advantage of this one error to <b>overflow</b> the buffer and overwrite important parts of memory with data of our choosing.

Now all we need to do is decide where we want to make the CPU to jump to.  The choice is an easy one: the `unlock_door` function!

We need enough data to first completely fill the buffer and then some.  The first 16 bytes don't matter, so we can enter any 16-byte sequence, for example `0xDE 0xAD 0xBE 0xEF 0xDE 0xAD 0xBE 0xEF 0xDE 0xAD 0xBE 0xEF 0xDE 0xAD 0xBE 0xEF` would be fine.  The last two bytes are what matter, and they need to contain the address of `unlock_door`.  From the assembly listing of `login`, we can see that the address of `unlock_door` is `0x4446`.  Remember that the CPU is little endian though, so the least significant byte goes first.  Therefore, the last two bytes of the "password" are `0x46 0x44`.  And there we have it, the special input that will open the lock.

Here's a quick rundown of what will happen when we use this password on the "real" lock: The lock will ask for the password, and we enter this 18-byte string.  The lock will copy it to the buffer, but because there's not enough room, it will end up overwriting the address it's supposed to return to with the address of `unlock_door`.  After getting the password, it will continue with asking the HSM to check the password, which will in turn tell it that it's wrong, and `login` will print to the screen the "That password is incorrect." message, and then finally execute the `ret` instruction.  At this point, the top of the stack, which contains the return address, has the value `0x4446`, which is the address of `unlock_door`.  And presto, even after lock determines that the password we gave was wrong, we still forced it to open up.

####Footnotes

* The eagle-eyed reader might have noticed that in `login`, we add a value to `sp` instead of subtracting from it to make room on the stack even though that's how I said it's done.  The value that we add is `0xFFF0`, which is the [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) of 16.  The two's complement of a value produces it's additive inverse, so `add #0xFFF0, sp` is actually equivalent to `sp` + (-16).

* In C, a `char` is always 1 byte long.  But how many bits are in a "byte" can vary between different CPUs.
